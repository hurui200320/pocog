package info.skyblond.pocog

import info.skyblond.pocog.WorldMap.Builder
import java.nio.IntBuffer
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

/**
 * The immutable representation of the map/world of the conway's game of life.
 * This is immutable, thus thread-safe and lock-free for reading.
 * Use [Builder] to create an instance.
 * */
@Suppress("MemberVisibilityCanBePrivate")
class WorldMap private constructor(
    /**
     * Width of the map.
     * How many cells a row has.
     * */
    val width: Int,
    /**
     * Height of the game.
     * How many rows a world map has.
     * */
    val height: Int,
    /**
     * The internal data for reading.
     * Generated by [Builder.build].
     * */
    private val data: Array<IntArray>
) {
    val wordWidth = data[0].size

    /**
     * Read the status of cell ([x],[y]).
     * Return true if cell is alive, false if cell is dead.
     * */
    operator fun get(x: Int, y: Int): Boolean {
        require(x in 0 until width) { "x out of bound" }
        require(y in 0 until height) { "y out of bound" }
        val wordIndex = x / Int.SIZE_BITS
        val wordOffset = x % Int.SIZE_BITS
        return data[y][wordIndex] and (1 shl wordOffset) != 0
    }

    /**
     * Count how many alive cells around cell ([x], [y]).
     * */
    fun countNeighbors(x: Int, y: Int): Int {
        var counter = 0
        for (i in x - 1..x + 1) {
            for (j in y - 1..y + 1) {
                if (i == x && j == y) continue
                // count if in range
                if (i in 0 until width && j in 0 until height) {
                    if (get(i, j)) counter++
                }
            }
        }
        return counter
    }

    /**
     * Write a row into [IntBuffer].
     * Make sure the [buffer] is ready to write.
     * After write, the [IntBuffer.rewind] will be invoked
     * and the [buffer] is ready to read.
     * */
    fun writeRowToIntBuffer(y: Int, buffer: IntBuffer) {
        require(buffer.remaining() == this.wordWidth) { "Wrong size. Expect ${this.wordWidth}, got: ${buffer.remaining()}" }
        if (y in 0 until height) {
            buffer.put(data[y])
            buffer.rewind()
        } else {
            buffer.put(IntArray(wordWidth) { 0 })
            buffer.rewind()
        }

    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is WorldMap) return false

        if (height != other.height) return false
        if (width != other.width) return false
        if (!data.contentDeepEquals(other.data)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = height
        result = 31 * result + width
        result = 31 * result + data.contentDeepHashCode()
        return result
    }

    /**
     * The builder of [WorldMap]. Kind-of thread safe.
     * For writing, it's thread-safe.
     * For building [WorldMap], it's not.
     * */
    class Builder(
        private val width: Int, private val height: Int
    ) {
        val wordWidth = width / Int.SIZE_BITS + if (width % Int.SIZE_BITS == 0) 0 else 1
        private val data = Array(height) { IntArray(wordWidth) }
        private val locks = Array(height) { ReentrantLock() }

        /**
         * Set cell ([x], [y]) to [newValue].
         * Thread-safe.
         * */
        operator fun set(x: Int, y: Int, newValue: Boolean) {
            require(y in 0 until height) { "y out of bound" }
            require(x in 0 until width) { "x out of bound" }
            val wordIndex = x / Int.SIZE_BITS
            val wordOffset = x % Int.SIZE_BITS
            locks[y].withLock {
                if (newValue) setTrue(wordIndex, wordOffset, y) else setFalse(wordIndex, wordOffset, y)
            }
        }

        private fun setTrue(wordIndex: Int, wordOffset: Int, y: Int) {
            val mask = 1 shl wordOffset
            data[y][wordIndex] = data[y][wordIndex] or mask
        }

        private fun setFalse(wordIndex: Int, wordOffset: Int, y: Int) {
            val mask = (1 shl wordOffset).inv()
            data[y][wordIndex] = data[y][wordIndex] and mask
        }

        /**
         * Read a row from [IntBuffer].
         * Make sure the [buffer] is ready to read.
         * After read, the [IntBuffer.rewind] will be invoked
         * and the [buffer] is ready to write.
         * */
        fun readRowFromIntBuffer(y: Int, buffer: IntBuffer) {
            require(buffer.remaining() == this.wordWidth) { "Wrong size. Expect ${this.wordWidth}, got: ${buffer.remaining()}" }
            if (y < 0 || y >= height) {
                return
            }
            locks[y].withLock {
                buffer.get(data[y])
            }
            buffer.rewind()
        }

        internal fun setBlock(y: Int, idx: Int, value: Int) {
            require(idx in 0 until this.wordWidth) { "Idx out of range: $idx" }
            require(y in 0 until height) { "Y out of range: $y" }
            locks[y].withLock {
                data[y][idx] = value
            }
        }

        /**
         * Copy the current status to a new array, and pack it into a [WorldMap].
         * This is not thread-safe as it copy rows one by one.
         * */
        fun build(): WorldMap {
            val result = Array(height) { IntArray(wordWidth) }
            for (i in data.indices) {
                locks[i].withLock {
                    System.arraycopy(data[i], 0, result[i], 0, wordWidth)
                }
            }
            return WorldMap(width, height, result)
        }
    }
}
